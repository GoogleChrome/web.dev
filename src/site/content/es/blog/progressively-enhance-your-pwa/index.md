---
layout: post
title: Mejore progresivamente su aplicaci√≥n web progresiva
subhead: Dise√±ando para navegadores modernos y mejorando progresivamente como en 2003
authors:
  - thomassteiner
description: Aprenda a mejorar progresivamente su aplicaci√≥n web progresiva para que siga siendo √∫til en todos los navegadores modernos, pero ofreciendo una experiencia avanzada en navegadores que admiten nuevas capacidades web como acceso al sistema de archivos, acceso al portapapeles del sistema, recuperaci√≥n de contactos, sincronizaci√≥n peri√≥dica en segundo plano, bloqueo de activaci√≥n de pantalla, funciones para compartir web, y muchos m√°s.
scheduled: true
date: 2020-06-29
updated: 2020-07-10
tags:
  - blog
  - capabilities
  - progressive-web-apps
hero: image/admin/0uSwSmGHmPXimU3dz8Xa.jpg
alt: Una imagen de un pez.
thumbnail: image/admin/X84uooDup0B9OYWY4ZKh.jpg
---

{% YouTube 'NXCT3htg9nk' %}

En marzo de 2003, [Nick Finck](https://twitter.com/nickf) y [Steve Champeon](https://twitter.com/schampeo) sorprendieron al mundo del dise√±o web con el concepto de [mejora progresiva](http://www.hesketh.com/publications/inclusive_web_design_for_the_future/), una estrategia para el dise√±o web que enfatiza la carga del contenido principal de la p√°gina web en primer lugar, y que luego agrega progresivamente capas de presentaci√≥n y caracter√≠sticas m√°s matizadas y t√©cnicamente rigurosas sobre el contenido. Mientras que en 2003, la mejora progresiva consist√≠a en usar, en ese momento, caracter√≠sticas modernas de CSS, JavaScript discreto e incluso gr√°ficos vectoriales escalables. La mejora progresiva en 2020 y despu√©s se trata de utilizar [las capacidades de los navegadores modernos](/fugu-status/).

<figure>
 {% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/IEOd4MT9BqnbeXQ7z0vC.png", alt="Dise√±o web inclusivo para el futuro con mejoras progresivas. Diapositiva de t√≠tulo de la presentaci√≥n original de Finck y Champeon.", width="800", height="597" %}
<figcaption>
 Diapositiva: Dise√±o web inclusivo para el futuro con mejoras progresivas.
 (<a href="http://www.hesketh.com/publications/inclusive_web_design_for_the_future/">Fuente</a>)
 </figcaption>
 </figure>

## JavaScript moderno

Hablando de JavaScript, la situaci√≥n de compatibilidad del navegador para las √∫ltimas funciones b√°sicas de JavaScript de ES 2015 es excelente. El nuevo est√°ndar incluye promesas, m√≥dulos, clases, literales de plantilla, funciones de flecha, `let` y `const`, par√°metros predeterminados, generadores, asignaci√≥n de desestructuraci√≥n, descanso y extensi√≥n, `Map`/`Set`, `WeakMap`/`WeakSet`, y muchos m√°s. [Todos son compatibles](https://caniuse.com/#feat=es6).

<figure>
{% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/sYcABrEPMr01C2ilp4B0.png", alt="La tabla de compatibilidad de CanIUse para las funciones de ES6 que muestra la compatibilidad con todos los navegadores principales.", width="800", height="296" %}
<figcaption>
 La tabla de compatibilidad del navegador ECMAScript 2015 (ES6). (<a href="https://caniuse.com/#feat=es6">Fuente</a>)
 </figcaption>
</figure>

Las funciones asincr√≥nicas, una caracter√≠stica de ES 2017 y una de mis favoritas, [se pueden utilizar](https://caniuse.com/#feat=async-functions) en todos los navegadores principales. Las palabras clave `async` y `await` permiten que el comportamiento asincr√≥nico basado en promesas se escriba en un estilo m√°s limpio, evitando la necesidad de configurar expl√≠citamente cadenas de promesas.

<figure>
 {% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/0WFlQTFFTlqXKvpROMu9.png", alt="La tabla de compatibilidad de CanIUse para funciones as√≠ncronas que muestra compatibilidad en todos los navegadores principales.", width="800", height="247" %}
 <figcaption>
  La tabla de soporte del navegador de funciones as√≠ncronas. (<a href="https://caniuse.com/#feat=async-functions">Fuente</a>)
  </figcaption>
</figure>

Incluso adiciones de lenguaje ES 2020 s√∫per recientes, como el [encadenamiento opcional](https://caniuse.com/#feat=mdn-javascript_operators_optional_chaining) y la[fusi√≥n nula](https://caniuse.com/#feat=mdn-javascript_operators_nullish_coalescing), se tornaron compatibles muy r√°pidamente. Puede ver un ejemplo de c√≥digo a continuaci√≥n. Cuando se trata de funciones b√°sicas de JavaScript, la situaci√≥n no podr√≠a estar mejor al d√≠a de hoy.

```js
const adventurer = {
  name: 'Alice',
  cat: {
    name: 'Dinah',
  },
};
console.log(adventurer.dog?.name);
// Expected output: undefined
console.log(0 ?? 42);
// Expected output: 0
```

<figure data-size="full">
 {% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/v1nhcTV9aaqPKd9oRvYz.png", alt="La imagen de fondo de hierba verde ic√≥nica de Windows XP.", width="800", height="500" %}
 <figcaption>
  Est√° mejor que nunca cuando se trata de funciones b√°sicas de JavaScript (captura de pantalla de producto de Microsoft, utilizada con <a href="https://www.microsoft.com/en-us/legal/intellectualproperty/permissions/default">permiso</a>.)</figcaption></figure>

## La aplicaci√≥n de muestra: Fugu Greetings

Para este art√≠culo, trabajo con una PWA simple, llamada [Fugu Greetings](https://tomayac.github.io/fugu-greetings/public/) ([GitHub](https://github.com/tomayac/fugu-greetings)). El nombre de esta aplicaci√≥n es un homenaje al Project Fugu üê°, un esfuerzo por darle a la web todos los poderes de las aplicaciones de escritorio/Android/iOS. Puede leer m√°s sobre el proyecto en su [p√°gina de inicio](/fugu-status).

Fugu Greetings es una aplicaci√≥n de dibujo que te permite crear tarjetas de felicitaci√≥n virtuales y envi√°rselas a tus seres queridos. Ejemplifica [los conceptos centrales de PWA](/progressive-web-apps/). Es [confiable](/reliable/) y est√° completamente habilitada sin conexi√≥n, por lo que puede usarla incluso si no est√° conectado a una red. Tambi√©n se puede [instalar](/install-criteria/) en la pantalla de inicio de un dispositivo y se integra perfectamente con el sistema operativo como una aplicaci√≥n independiente.

<figure>
{% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/w0id013BKBF2z7m70TrX.png", alt="PWA Fugu Greetings con un dibujo que se asemeja al logo de la comunidad de PWA.", width="800", height="543" %}
<figcaption>
 La aplicaci√≥n de muestra <a href="https://tomayac.github.io/fugu-greetings/public/">Fugu Greetings.</a>
 </figcaption>
 </figure>

## Mejora progresiva

Con esto fuera del camino, es hora de hablar sobre la *mejora progresiva*. El glosario de MDN Web Docs [define](https://developer.mozilla.org/docs/Glossary/Progressive_Enhancement) el concepto de la siguiente manera:

{% Blockquote 'MDN contributors' %}
La mejora progresiva es una filosof√≠a de dise√±o que proporciona una l√≠nea de base de contenido y funcionalidad esenciales para tantos usuarios como sea posible, al tiempo que brinda la mejor experiencia posible solo a los usuarios de los navegadores m√°s modernos que pueden ejecutar todo el c√≥digo requerido.

[La detecci√≥n de caracter√≠sticas](https://developer.mozilla.org/docs/Learn/Tools_and_testing/Cross_browser_testing/Feature_detection) se usa generalmente para determinar si los navegadores pueden manejar una funcionalidad m√°s moderna, mientras que los [polyfills](https://developer.mozilla.org/docs/Glossary/Polyfill) se usan a menudo para agregar caracter√≠sticas faltantes con JavaScript.

[‚Ä¶]

La mejora progresiva es una t√©cnica √∫til que permite a los desarrolladores web concentrarse en desarrollar los mejores sitios web posibles mientras hacen que esos sitios web funcionen en m√∫ltiples agentes de usuario desconocidos. [La degradaci√≥n elegante](https://developer.mozilla.org/docs/Glossary/Graceful_degradation) est√° relacionada, pero no es lo mismo y, a menudo, se considera que va en la direcci√≥n opuesta a la mejora progresiva. En realidad, ambos enfoques son v√°lidos y, a menudo, pueden complementarse entre s√≠. {% endBlockquote %}

{% Aside 'note' %}
 Este no es un art√≠culo introductorio sobre la mejora progresiva, pero se supone que est√° familiarizado con el concepto. Para una base s√≥lida, recomiendo el art√≠culo de Steve Champeon [Mejora progresiva y el futuro del dise√±o web](http://www.hesketh.com/progressive_enhancement_and_the_future_of_web_design.html).
{% endAside %}

Comenzar cada tarjeta de felicitaci√≥n desde cero puede ser realmente engorroso. Entonces, ¬øpor qu√© no tener una funci√≥n que permita a los usuarios importar una imagen y comenzar desde all√≠? Con un enfoque tradicional, habr√≠a utilizado un elemento [`<input type=file>`](https://developer.mozilla.org/docs/Web/HTML/Element/input/file) para que esto suceda. Primero, crear√≠a el elemento, establecer√≠a su `type` en `'file'` y agregar√≠a tipos MIME a la propiedad `accept`, y luego har√≠a "clic" en √©l mediante programaci√≥n y sondar√≠a los cambios. Cuando seleccione una imagen, se importa directamente al lienzo.

```js
const importImage = async () => {
  return new Promise((resolve) => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.addEventListener('change', () => {
      resolve(input.files[0]);
    });
    input.click();
  });
};
```

Cuando hay una *funci√≥n de importaci√≥n*, probablemente deber√≠a haber una *funci√≥n de exportaci√≥n* para que los usuarios puedan guardar sus tarjetas de felicitaci√≥n localmente. La forma tradicional de guardar archivos es crear un enlace de anclaje con un atributo [`download`](https://developer.mozilla.org/docs/Web/HTML/Element/a#download) y con una URL de blob como su `href`. Tambi√©n deber√≠a "hacer clic" en √©l mediante programaci√≥n para activar la descarga y, con suerte, para evitar p√©rdidas de memoria, no olvide revocar la URL del objeto blob.

```js
const exportImage = async (blob) => {
  const a = document.createElement('a');
  a.download = 'fugu-greeting.png';
  a.href = URL.createObjectURL(blob);
  a.addEventListener('click', (e) => {
    setTimeout(() => URL.revokeObjectURL(a.href), 30 * 1000);
  });
  a.click();
};
```

Pero espere un minuto. Mentalmente, no ha "descargado" una tarjeta de felicitaci√≥n, la ha "guardado". En lugar de mostrarle un cuadro de di√°logo "guardar" que le permite elegir d√≥nde colocar el archivo, el navegador descarg√≥ directamente la tarjeta de felicitaci√≥n sin interacci√≥n del usuario y la coloc√≥ directamente en su carpeta Downloads. Esto no es lo ideal.

¬øY si hubiera una forma mejor? ¬øQu√© pasar√≠a si pudiera abrir un archivo local, editarlo y luego guardar las modificaciones, ya sea en un archivo nuevo o en el archivo original que hab√≠a abierto inicialmente? Resulta que la hay. La [API de acceso al sistema de archivos](/file-system-access/) (File System Access API) le permite abrir y crear archivos y directorios, as√≠ como modificarlos y guardarlos.

Entonces, ¬øc√≥mo detecto una API? La API de acceso al sistema de archivos expone un nuevo m√©todo `window.chooseFileSystemEntries()`. En consecuencia, necesito cargar condicionalmente diferentes m√≥dulos de importaci√≥n y exportaci√≥n dependiendo de si este m√©todo est√° disponible. Demuestro c√≥mo hacer esto a continuaci√≥n.

```js
const loadImportAndExport = () => {
  if ('chooseFileSystemEntries' in window) {
    Promise.all([
      import('./import_image.mjs'),
      import('./export_image.mjs'),
    ]);
  } else {
    Promise.all([
      import('./import_image_legacy.mjs'),
      import('./export_image_legacy.mjs'),
    ]);
  }
};
```

Pero antes de entrar de lleno en los detalles de la API de acceso al sistema de archivos, perm√≠tanme destacar r√°pidamente el patr√≥n de mejora progresiva aqu√≠. En los navegadores que actualmente no son compatibles con la API de acceso al sistema de archivos, cargo los scripts heredados. Puede ver las pesta√±as de red de Firefox y Safari a continuaci√≥n.

<figure>
{% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/rnPL8xIMt6HJEUbDfrez.png", alt="Safari Web Inspector muestra los archivos heredados que se cargan.", width="800", height="114" %}
<figcaption>
 Pesta√±a de red Safari Web Inspector.
 </figcaption>
 </figure>

<figure>
{% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/bui4rcv0jvlVLHI3jBoo.png", alt="Herramientas de desarrollo de Firefox que muestran los archivos heredados que se cargan.", width="800", height="166" %}
<figcaption>
 Pesta√±a de red Firefox Developer Tools.
 </figcaption>
 </figure>

Sin embargo, en Chrome, un navegador que admite la API, solo se cargan los nuevos scripts. Esto se hace posible de forma elegante gracias a [dynamic `import()`](https://v8.dev/features/dynamic-import), que todos los navegadores modernos [soportan](https://caniuse.com/#feat=es6-module-dynamic-import). Como dije anteriortmente, las cosas van viento en popa hoy en d√≠a.

<figure>
{% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/plf6kGtFE8g9Fjogv8ia.png", alt="Chrome DevTools que muestra los archivos modernos que se cargan.", width="800", height="241" %}
<figcaption>
 Pesta√±a de red Chrome DevTools.
 </figcaption>
 </figure>

## La API de acceso al sistema de archivos

Entonces, ahora que he abordado esto, es hora de ver la implementaci√≥n real basada en la API de acceso al sistema de archivos. Para importar una imagen, llamo `window.chooseFileSystemEntries()` y le paso una propiedad `accepts` donde establezco que quiero archivos de imagen. Se admiten tanto extensiones de archivo como los tipos MIME. Esto da como resultado un identificador de archivo, del cual puedo obtener el archivo real llamando a `getFile()`.

```js
const importImage = async () => {
  try {
    const handle = await window.chooseFileSystemEntries({
      accepts: [
        {
          description: 'Image files',
          mimeTypes: ['image/*'],
          extensions: ['jpg', 'jpeg', 'png', 'webp', 'svg'],
        },
      ],
    });
    return handle.getFile();
  } catch (err) {
    console.error(err.name, err.message);
  }
};
```

Exportar una imagen es casi lo mismo, pero esta vez necesito pasar un par√°metro de tipo de `'save-file'` al m√©todo `chooseFileSystemEntries()`. A partir de esto, obtengo un cuadro de di√°logo para guardar archivos. Con el archivo abierto, esto no era necesario porque `'open-file'` es el valor predeterminado. He establecido el par√°metro `accepts` de forma similar al anterior, pero esta vez limitado solamente a im√°genes PNG. Nuevamente, recupero un identificador de archivo, pero en lugar de obtener el archivo, esta vez creo una secuencia de escritura llamando a `createWritable()`. A continuaci√≥n, escribo el blob, que es la imagen de mi tarjeta de felicitaci√≥n, en el archivo. Finalmente, cierro la secuencia de escritura.

Todo puede fallar: el disco podr√≠a quedarse sin espacio, podr√≠a haber un error de escritura o lectura, o tal vez simplemente el usuario cancele el cuadro de di√°logo del archivo. Es por eso que siempre envuelvo las llamadas en una declaraci√≥n `try...catch`.

```js
const exportImage = async (blob) => {
  try {
    const handle = await window.chooseFileSystemEntries({
      type: 'save-file',
      accepts: [
        {
          description: 'Image file',
          extensions: ['png'],
          mimeTypes: ['image/png'],
        },
      ],
    });
    const writable = await handle.createWritable();
    await writable.write(blob);
    await writable.close();
  } catch (err) {
    console.error(err.name, err.message);
  }
};
```

Utilizando la mejora progresiva con la API de acceso al sistema de archivos, puedo abrir un archivo como antes. El archivo importado se dibuja directamente en el lienzo. Puedo hacer mis ediciones y finalmente guardarlas con un cuadro de di√°logo de guardado real donde puedo elegir el nombre y la ubicaci√≥n de almacenamiento del archivo. Ahora el archivo est√° listo para conservarse por la eternidad.

<figure>
{% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/TEKHbetFMURVWh4QPRJw.png", alt="Aplicaci√≥n Fugu Greetings con un cuadro de di√°logo para abrir archivo.", width="800", height="480" %}
<figcaption>
 El di√°logo abrir de archivo.
 </figcaption>
 </figure>

<figure>
{% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/tls52mkxDB513SzzcfNj.png", alt="La aplicaci√≥n Fugu Greetings ahora con una imagen importada.", width="800", height="480" %}
<figcaption>
 La imagen importada.
 </figcaption>
 </figure>

<figure>
{% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/3LwHvtROaN1bHJN1El5D.png", alt="Aplicaci√≥n Fugu Greetings con la imagen modificada", width="800", height="480" %}
<figcaption>
 Guardando la imagen modificada en un nuevo archivo.
</figcaption>
</figure>

## Las API Web Share y Web Share Target

Adem√°s de almacenarla por toda la eternidad, tal vez realmente quiera compartir mi tarjeta de felicitaci√≥n. Esto es algo que la [API Web Share](/web-share/) y la [API Web Share Target](/web-share-target/) me permiten hacer. Los sistemas operativos m√≥viles y, m√°s recientemente, los de escritorio, han adquirido mecanismos de intercambio integrados. Por ejemplo, a continuaci√≥n se muestra la hoja para compartir de Safari de escritorio en macOS activada desde un art√≠culo de mi [blog](https://blog.tomayac.com/). Cuando hace clic en el bot√≥n **Compartir art√≠culo**, puedes compartir un enlace al art√≠culo con un amigo, por ejemplo, a trav√©s de la aplicaci√≥n Mensajes de macOS.

<figure>
{% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/sinRHRHFgSgwAC7x8dIZ.png", alt="Hoja para compartir de Desktop Safari en macOS activada desde el bot√≥n Compartir de un art√≠culo", width="800", height="423" %}
<figcaption>
 API Web Share en Safari de escritorio para macOS.
 </figcaption>
 </figure>

El c√≥digo para que esto suceda es bastante sencillo. Llamo `navigator.share()` y le paso un `title`, un `text` y un `url` opcionales en un objeto. Pero, ¬øy si quiero adjuntar una imagen? El nivel 1 de la API Web Share a√∫n no admite esto. La buena noticia es que Web Share Level 2 ha agregado capacidades para compartir archivos.

```js
try {
  await navigator.share({
    title: 'Check out this article:',
    text: `"${document.title}" by @tomayac:`,
    url: document.querySelector('link[rel=canonical]').href,
  });
} catch (err) {
  console.warn(err.name, err.message);
}
```

D√©jame mostrarte c√≥mo hacer que esto funcione con la aplicaci√≥n Fugu Greetings. Primero, necesito preparar un objeto de `data` con un array de `archivos` que consiste de un blob, y luego un `title` y un `text`. A continuaci√≥n, como pr√°ctica recomendada, utilizo el nuevo `navigator.canShare()` que hace lo que sugiere su nombre: me dice si el objeto de `data` que estoy tratando de compartir puede t√©cnicamente ser compartido por el navegador. Si `navigator.canShare()` me dice que los datos se pueden compartir, estoy listo para llamar a `navigator.share()` como antes. Como todo puede fallar, de nuevo estoy usando un bloque `try...catch`.

```js
const share = async (title, text, blob) => {
  const data = {
    files: [
      new File([blob], 'fugu-greeting.png', {
        type: blob.type,
      }),
    ],
    title: title,
    text: text,
  };
  try {
    if (!(navigator.canShare(data))) {
      throw new Error("Can't share data.", data);
    }
    await navigator.share(data);
  } catch (err) {
    console.error(err.name, err.message);
  }
};
```

Como antes, utilizo la mejora progresiva. Si tanto `'share'` como `'canShare'` existen en el objeto `navigator`, solo entonces cargo `share.mjs` a trav√©s de la `import()` din√°mica. En navegadores como Safari m√≥vil que solo cumplen una de las dos condiciones, no cargo la funcionalidad.

```js
const loadShare = () => {
  if ('share' in navigator && 'canShare' in navigator) {
    import('./share.mjs');
  }
};
```

En Fugu Greetings, si toco el bot√≥n **Compartir** en un navegador compatible como Chrome en Android, se abre la hoja para compartir incorporada. Puedo, por ejemplo, escoger Gmail, y el widget del redactor de correo electr√≥nico aparece con la imagen adjunta.

<div class="switcher">
  <figure>
   {% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/szInJQl908kv9GEU8EJf.png", alt="Hoja para compartir a nivel de SO que muestra varias aplicaciones para compartir la imagen.", width="800", height="1645" %}
   <figcaption>
    Elecci√≥n de una aplicaci√≥n para compartir el archivo.
   </figcaption>
  </figure>

  <figure>
   {% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/mKmdg1OMGpWDukmfSSOl.png", alt="Widget de redacci√≥n de correo electr√≥nico de Gmail con la imagen adjunta.", width = "800", height = "1645" %}
   <figcaption>
     El archivo se adjunta a un nuevo correo electr√≥nico en el redactor de Gmail.
   </figcaption>
  </figure>
</div>  

## La API de selecci√≥n de contactos

A continuaci√≥n, quiero hablar sobre contactos, es decir, la libreta de direcciones de un dispositivo o la aplicaci√≥n de administrador de contactos. Cuando escribe una tarjeta de felicitaci√≥n, puede que no siempre sea f√°cil escribir correctamente el nombre de alguien. Por ejemplo, tengo un amigo Sergey que prefiere que su nombre se escriba en cir√≠lico. Estoy usando un teclado QWERTZ alem√°n y no tengo idea de c√≥mo escribir su nombre. Este es un problema que la [API de selecci√≥nr de contactos](/contact-picker/) puede resolver. Como tengo a mi amigo almacenado en la aplicaci√≥n de contactos de mi tel√©fono, puedo acceder a mis contactos desde la web a trav√©s de esta API.

Primero, necesito especificar la lista de propiedades a las que quiero acceder. En este caso, solo quiero los nombres, pero para otros casos de uso, podr√≠a estar interesado en n√∫meros de tel√©fono, correos electr√≥nicos, √≠conos de avatar o direcciones f√≠sicas. A continuaci√≥n, configuro un objeto `options` con el valor de `multiple` ajustado en `true`, de modo que puedo seleccionar m√°s de una entrada. Finalmente, puedo llamar a `navigator.contacts.select()`, que devuelve las propiedades deseadas para los contactos seleccionados por el usuario.

```js
const getContacts = async () => {
  const properties = ['name'];
  const options = { multiple: true };
  try {
    return await navigator.contacts.select(properties, options);
  } catch (err) {
    console.error(err.name, err.message);
  }
};
```

Y probablemente ya ha aprendido el patr√≥n: solo cargo el archivo cuando la API es realmente compatible.

```js
if ('contacts' in navigator) {
  import('./contacts.mjs');
}
```

En Fugu Greeting, cuando toco el **bot√≥n Contactos** y selecciono a mis dos mejores amigos,
[–°–µ—Ä–≥–µ–π –ú–∏—Ö–∞–π–ª–æ–≤–∏—á –ë—Ä–∏–Ω](https://ru.wikipedia.org/wiki/%D0%91%D1%80%D0%B8%D0%BD,_%D0%A1%D0%B5%D1%80%D0%B3%D0%B5%D0%B9_%D0%9C%D0%B8%D1%85%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D0%B8%D1%87) y [Âä≥‰º¶ÊñØ¬∑Áà±Âæ∑Âçé¬∑"ÊãâÈáå"¬∑‰Ω©Â•á](https://zh.wikipedia.org/wiki/%E6%8B%89%E9%87%8C%C2%B7%E4%BD%A9%E5%A5%87), puedes ver c√≥mo el selector de contactos se limita a mostrar solo sus nombres, pero no sus direcciones de correo electr√≥nico u otra informaci√≥n como sus n√∫meros de tel√©fono. Luego, sus nombres se incorporan a mi tarjeta de felicitaci√≥n.

<div class="switcher">
  <figure>
   {% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/T5gmSr1XGiVIV9Pw1HbC.png", alt="Selector de contactos que muestra los nombres de dos contactos en la libreta de direcciones.", width="800", height="1645" %}
   <figcaption>
    Selecci√≥n de dos nombres con el selector de contactos de la libreta de direcciones.
   </figcaption>
   </figure>

  <figure>
   {% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/ioMOCEHwvwdyzS7DX5L8.png", alt="Los nombres de los dos contactos seleccionados previamente incorporados a la tarjeta de felicitaci√≥n.", width="800", height="1644" %}
   <figcaption>
    Luego, los dos nombres se incorporan a la tarjeta de felicitaci√≥n.
   </figcaption>
  </figure>
</div>


## La API del portapapeles as√≠ncrono

Lo siguiente es copiar y pegar. Una de nuestras operaciones favoritas como desarrolladores de software es copiar y pegar. Como autor de tarjetas de felicitaci√≥n, a veces, es posible que desee hacer lo mismo. Es posible que quiera pegar una imagen en una tarjeta de felicitaci√≥n en la que estoy trabajando o copiar mi tarjeta de felicitaci√≥n para poder seguir edit√°ndola desde otro lugar. La [API del portapapeles as√≠ncrono](/image-support-for-async-clipboard/) (API Async Clipboard) admite texto e im√°genes. D√©jame explicarte c√≥mo agregu√© el soporte para copiar y pegar a la aplicaci√≥n Fugu Greetings.

Para copiar algo en el portapapeles del sistema, necesito escribir en √©l. El `navigator.clipboard.write()` toma una matriz de elementos del portapapeles como par√°metro. Cada elemento del portapapeles es esencialmente un objeto con un blob como valor y el tipo del blob como clave.

```js
const copy = async (blob) => {
  try {
    await navigator.clipboard.write([
      new ClipboardItem({
        [blob.type]: blob,
      }),
    ]);
  } catch (err) {
    console.error(err.name, err.message);
  }
};
```

Para pegar, necesito recorrer los elementos obtenidos del portapapeles llamando a `navigator.clipboard.read()`. La raz√≥n de esto es que varios elementos del portapapeles pueden estar en el portapapeles en diferentes representaciones. Cada elemento del portapapeles tiene un campo `types` que me dice los tipos MIME de los recursos disponibles. Llamo al `getType()` del elemento del portapapeles, pasando el tipo MIME que obtuve antes.

```js
const paste = async () => {
  try {
    const clipboardItems = await navigator.clipboard.read();
    for (const clipboardItem of clipboardItems) {
      try {
        for (const type of clipboardItem.types) {
          const blob = await clipboardItem.getType(type);
          return blob;
        }
      } catch (err) {
        console.error(err.name, err.message);
      }
    }
  } catch (err) {
    console.error(err.name, err.message);
  }
};
```

Y pr√°cticamente no hace falta decirlo a estas alturas. Solo hago esto en navegadores compatibles.

```js
if ('clipboard' in navigator && 'write' in navigator.clipboard) {
  import('./clipboard.mjs');
}
```

Entonces, ¬øc√≥mo funciona esto en la pr√°ctica? Tengo una imagen abierta en la aplicaci√≥n macOS Preview y la copio al portapapeles. Cuando hago clic en **Pegar**, la aplicaci√≥n Fugu Greetings me pregunta si quiero permitir que la aplicaci√≥n vea texto e im√°genes en el portapapeles.

<figure>
{% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/EO9BemEDnDtO3SvLl8u5.png", alt="La aplicaci√≥n Fugu Greetings muestra la solicitud de permiso del portapapeles.", width="800", height="543" %}
 <figcaption>
  La solicitud de permiso del portapapeles.
  </figcaption>
</figure>

Finalmente, despu√©s de aceptar el permiso, la imagen se pega en la aplicaci√≥n. Tambi√©n funciona al rev√©s. D√©jame copiar una tarjeta de felicitaci√≥n en el portapapeles. Cuando abro Preview y hago clic en **File** y luego en **New desde el portapapeles**, la tarjeta de felicitaci√≥n se pega en una nueva imagen sin t√≠tulo.

<figure>
 {% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/VAkvEYWsQsJ0VJ8IjEs1.png", alt="La aplicaci√≥n de vista previa de macOS con una imagen sin t√≠tulo, reci√©n pegada.", width="800", height="464" %}
<figcaption>
 Una imagen pegada en la aplicaci√≥n macOS Preview.
 </figcaption>
 </figure>

## La API de credenciales

Otra API √∫til es la [API de credenciales](/badging-api/) (Badging API). Como PWA instalable, Fugu Greetings, por supuesto, tiene un √≠cono de aplicaci√≥n que los usuarios pueden colocar en la barra de tareas o en la pantalla de inicio. Una forma f√°cil y divertida de demostrar la API es (ab) usarla en Fugu Greetings como un contador de trazos de l√°piz. He agregado un detector de eventos que incrementa el contador de trazos de l√°piz a cada evento `pointerdown` y luego establece la credencial del icono actualizada. Siempre que se borra el lienzo, el contador se reinicia y se quita la credencial.

```js
let strokes = 0;

canvas.addEventListener('pointerdown', () => {
  navigator.setAppBadge(++strokes);
});

clearButton.addEventListener('click', () => {
  strokes = 0;
  navigator.setAppBadge(strokes);
});
```

Esta caracter√≠stica es una mejora progresiva, por lo que la l√≥gica de carga es la habitual.

```js
if ('setAppBadge' in navigator) {
  import('./badge.mjs');
}
```

En este ejemplo, dibuj√© los n√∫meros del uno al siete, usando un trazo de l√°piz por n√∫mero. El contador de insignias en el icono ahora est√° en siete.

<figure>
 {% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/uKurKxYeRlLCLXJYhX9I.png", alt="Los n√∫meros del uno al siete dibujados en la tarjeta de felicitaci√≥n, cada uno con un solo trazo de l√°piz.", width="800", height="480" %}
 <figcaption>
  Dibujo de los n√∫meros del 1 al 7 con siete trazos de l√°piz.
 </figcaption>
</figure>

<figure>
{% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/5uOcN2MdjKVnWXRyTmCG.png", alt="Icono de insignia en la aplicaci√≥n Fugu Greetings que muestra el n√∫mero 7.", width="742", height="448" %}
<figcaption>
El contador de trazos de l√°piz tiene la forma de la credencial del icono de la aplicaci√≥n.
</figcaption>
</figure>

## La API de sincronizaci√≥n peri√≥dica en segundo plano

¬øQuiere empezar cada d√≠a con algo nuevo? Una caracter√≠stica interesante de la aplicaci√≥n Fugu Greetings es que puede inspirarte cada ma√±ana con una nueva imagen de fondo para comenzar tu tarjeta de felicitaci√≥n. La aplicaci√≥n utiliza la [API de sincronizaci√≥n peri√≥dica en segundo plano](/periodic-background-sync/) para lograr esto.

El primer paso es *registrar* un evento de sincronizaci√≥n peri√≥dica en el registro del service worker. Escucha una etiqueta de sincronizaci√≥n llamada `'image-of-the-day'` y tiene un intervalo m√≠nimo de un d√≠a, por lo que el usuario puede obtener una nueva imagen de fondo cada 24 horas.

```js
const registerPeriodicBackgroundSync = async () => {
  const registration = await navigator.serviceWorker.ready;
  try {
    registration.periodicSync.register('image-of-the-day-sync', {
      // An interval of one day.
      minInterval: 24 * 60 * 60 * 1000,
    });
  } catch (err) {
    console.error(err.name, err.message);
  }
};
```

El segundo paso es *escuchar* el evento `periodicsync` en el service worker. Si la etiqueta del evento es `'image-of-the-day'`, es decir, la que se registr√≥ antes, la imagen del d√≠a se recupera mediante la funci√≥n `getImageOfTheDay()` y el resultado se propaga a todos los clientes, para que puedan actualizar sus lienzos y cach√©s.

```js
self.addEventListener('periodicsync', (syncEvent) => {
  if (syncEvent.tag === 'image-of-the-day-sync') {
    syncEvent.waitUntil(
      (async () => {
        const blob = await getImageOfTheDay();
        const clients = await self.clients.matchAll();
        clients.forEach((client) => {
          client.postMessage({
            image: blob,
          });
        });
      })()
    );
  }
});
```

Nuevamente, esto es realmente una mejora progresiva, por lo que el c√≥digo solo se carga cuando la API es compatible con el navegador. Esto se aplica tanto al c√≥digo del cliente como al c√≥digo del service worker. En los navegadores que no son compatibles, ninguno de ellos se carga. Nota c√≥mo en el service worker, en lugar de un `import()` din√°mico (que no es compatible en el contexto del service worker [yet](https://github.com/w3c/ServiceWorker/issues/1356#issuecomment-433411852)), utilizo los cl√°sicos [`importScripts()`](https://developer.mozilla.org/docs/Web/API/WorkerGlobalScope/importScripts).

```js
// In the client:
const registration = await navigator.serviceWorker.ready;
if (registration && 'periodicSync' in registration) {
  import('./periodic_background_sync.mjs');
}
```

```js
// In the service worker:
if ('periodicSync' in self.registration) {
  importScripts('./image_of_the_day.mjs');
}
```

En Fugu Greetings, al presionar el bot√≥n **Fondo de pantalla** se muestra la imagen de la tarjeta de felicitaci√≥n del d√≠a que se actualiza todos los d√≠as a trav√©s de la API de sincronizaci√≥n peri√≥dica en segundo plano.

<figure>
 {% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/YdSHSI4pZcTPyVv8CVx8.png", alt="Aplicaci√≥n Fugu Greetings con una nueva imagen de tarjeta de felicitaci√≥n del d√≠a.", width="800", height="481" %}
 <figcaption>
  Al presionar el bot√≥n <strong>Fondo de pantalla</strong> se muestra la imagen del d√≠a.
 </figcaption>
</figure>

## API de activaci√≥n de notificaciones

A veces, incluso con mucha inspiraci√≥n, necesita un peque√±o empuj√≥n para terminar una tarjeta de felicitaci√≥n iniciada. Esta es una funci√≥n que est√° habilitada por la [API de activaci√≥n de notificaciones](/notification-triggers/). Como usuario, puedo ingresar una hora en la que quiero que me notifiquen para terminar mi tarjeta de felicitaci√≥n. Cuando llegue ese momento, recibir√© una notificaci√≥n de que mi tarjeta de felicitaci√≥n est√° esperando.

Despu√©s de solicitar el tiempo objetivo, la aplicaci√≥n programa la notificaci√≥n con un `showTrigger`. Puede ser un `TimestampTrigger` con la fecha objetivo previamente seleccionada. La notificaci√≥n de recordatorio se activar√° localmente, no se necesita red ni servidor.

```js
const targetDate = promptTargetDate();
if (targetDate) {
  const registration = await navigator.serviceWorker.ready;
  registration.showNotification('Reminder', {
    tag: 'reminder',
    body: "It's time to finish your greeting card!",
    showTrigger: new TimestampTrigger(targetDate),
  });
}
```

Como con todo lo dem√°s que he mostrado hasta ahora, esta es una mejora progresiva, por lo que el c√≥digo solo se carga condicionalmente.

```js
if ('Notification' in window && 'showTrigger' in Notification.prototype) {
  import('./notification_triggers.mjs');
}
```

Cuando marco la casilla de verificaci√≥n **Recordatorio** en Fugu Greetings, un mensaje me pregunta cu√°ndo quiero que se me recuerde que debo terminar mi tarjeta de felicitaci√≥n.

<figure>
 {% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/xtD7PtIIBO0Yn1ISFSyz.png", alt="Aplicaci√≥n Fugu Greetings con un mensaje que pregunta al usuario cu√°ndo quiere que se le recuerde que termine su tarjeta de felicitaci√≥n.", width="800", height="480" %}
  <figcaption>
   Programaci√≥n de una notificaci√≥n local para recordarle que debe terminar una tarjeta de felicitaci√≥n.
  </figcaption>
</figure>

Cuando se activa una notificaci√≥n programada en Fugu Greetings, se muestra como cualquier otra notificaci√≥n, pero como escrib√≠ antes, no fue necesaria una conexi√≥n de red.

<figure>
 {% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/e1FJA11UE3lrL1d4mCCo.png", alt="Centro de notificaciones de macOS que muestra una notificaci√≥n activada de Fugu Greetings.", width="300", height="172" %}
  <figcaption>
   La notificaci√≥n activada aparece en el Centro de notificaciones de macOS.
  </figcaption>
</figure>

## La API de Wake Lock

Tambi√©n quiero incluir la [API de Wake Lock](/wakelock/) . A veces solo necesitas mirar fijamente la pantalla el tiempo suficiente hasta que la inspiraci√≥n te llegue. Lo peor que puede pasar es que la pantalla se apague. La API de Wake Lock puede evitar que esto suceda.

El primer paso es obtener un wake lock con el `navigator.wakelock.request method()`. Le paso la cadena `'screen'` para obtener un wake lock. Luego agrego un detector de eventos para ser informado cuando se libera el wake lock. Esto puede suceder, por ejemplo, cuando cambia la visibilidad de la pesta√±a. Si esto sucede, puedo, cuando la pesta√±a vuelva a ser visible, volver a obtener el wake lock.

```js
let wakeLock = null;
const requestWakeLock = async () => {
  wakeLock = await navigator.wakeLock.request('screen');
  wakeLock.addEventListener('release', () => {
    console.log('Wake Lock was released');
  });
  console.log('Wake Lock is active');
};

const handleVisibilityChange = () => {
  if (wakeLock !== null && document.visibilityState === 'visible') {
    requestWakeLock();
  }
};

document.addEventListener('visibilitychange', handleVisibilityChange);
document.addEventListener('fullscreenchange', handleVisibilityChange);
```

S√≠, esta es una mejora progresiva, por lo que solo necesito cargarla cuando el navegador admita la API.

```js
if ('wakeLock' in navigator && 'request' in navigator.wakeLock) {
  import('./wake_lock.mjs');
}
```

En Fugu Greetings, hay una **casilla de verificaci√≥n Insomnia** que, cuando est√° marcada, mantiene la pantalla activa.

<figure>
 {% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/kB5LkdV3cVKaJ0Xze76v.png", alt="La casilla de insomnia, si est√° marcada, mantiene la pantalla activa.", width="800", height="480" %}
 <figcaption>
  La casilla de verificaci√≥n <strong>Insomnia</strong> mantiene la aplicaci√≥n activa.
 </figcaption>
</figure>

## La API de detecci√≥n de inactividad

A veces, incluso si miras la pantalla durante horas, es in√∫til y no se te ocurre la menor idea de qu√© hacer con tu tarjeta de felicitaci√≥n. La [API de detecci√≥n de inactividad](/idle-detection/) permite que la aplicaci√≥n detecte el tiempo de inactividad del usuario. Si el usuario est√° inactivo durante demasiado tiempo, la aplicaci√≥n se restablece al estado inicial y borra el lienzo. Esta API actualmente est√° bloqueada detr√°s del [permiso de notificaciones](https://developer.mozilla.org/docs/Web/API/Notification/requestPermission) , ya que muchos casos de uso de producci√≥n de detecci√≥n inactiva est√°n relacionados con notificaciones, por ejemplo, para enviar solo una notificaci√≥n a un dispositivo que el usuario est√° usando actualmente de forma activa.

Despu√©s de asegurarme de que se otorgue el permiso de notificaciones, entonces creo una instancia del detector inactivo. Registro un detector de eventos que escucha los cambios inactivos, que incluye el usuario y el estado de la pantalla. El usuario puede estar activo o inactivo y la pantalla se puede desbloquear o bloquear. Si el usuario est√° inactivo, el lienzo se borra. Le doy al detector inactivo un umbral de 60 segundos.

```js
const idleDetector = new IdleDetector();
idleDetector.addEventListener('change', () => {
  const userState = idleDetector.userState;
  const screenState = idleDetector.screenState;
  console.log(`Idle change: ${userState}, ${screenState}.`);
  if (userState === 'idle') {
    clearCanvas();
  }
});

await idleDetector.start({
  threshold: 60000,
  signal,
});
```

Y como siempre, solo cargo este c√≥digo cuando el navegador lo admite.

```js
if ('IdleDetector' in window) {
  import('./idle_detection.mjs');
}
```

En la aplicaci√≥n Fugu Greetings, el lienzo se borra cuando la casilla de verificaci√≥n **Ephemeral** est√° marcada y el usuario est√° inactivo durante demasiado tiempo.

<figure>
 {% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/yq3IsOqp01AZTw7nvfnB.png", alt="La aplicaci√≥n Fugu Greetings con un lienzo despejado despu√©s de que el usuario ha estado inactivo durante demasiado tiempo.", width="800", height="480" %}
  <figcaption>
   Cuando la casilla de verificaci√≥n <strong>Ephemeral</strong> est√° marcada y el usuario ha estado inactivo durante demasiado tiempo, el lienzo se borra.
  </figcaption>
</figure>

## Conclusi√≥n

Uf, qu√© paseo. Tantas API en una sola aplicaci√≥n de muestra. Y recuerde, nunca hacemos que el usuario pague el costo de descarga de una funci√≥n que su navegador no admite. Al usar la mejora progresiva, me aseguro de que solo se cargue el c√≥digo relevante. Y dado que con HTTP/2, las solicitudes son baratas, este patr√≥n deber√≠a funcionar bien para muchas aplicaciones, aunque es posible que desee considerar un paquete para aplicaciones realmente grandes.

<figure>
 {% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/DOnuk7CHPsnbTdlqOHXM.png", alt="El panel Chrome DevTools Network muestra solo solicitudes de archivos con c√≥digo compatible con el navegador actual.", width="800", height="566" %}
 <figcaption>
  La pesta√±a de DevTools de Chrome muestra solo las solicitudes de archivos con c√≥digo compatible con el navegador actual.
 </figcaption>
</figure>

La aplicaci√≥n puede aparecer un poco diferente en cada navegador, ya que no todas las plataformas admiten todas las funciones, pero la funcionalidad principal siempre est√° disponible, mejorada progresivamente de acuerdo con las capacidades del navegador espec√≠fico. Tenga en cuenta que estas capacidades pueden cambiar incluso en el mismo navegador, dependiendo de si la aplicaci√≥n se ejecuta como una aplicaci√≥n instalada o en una pesta√±a del navegador.

<figure>
 {% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/LmUW0CZpH5eXIoHTZ6kH.png", alt="Fugu Greetings en Android Chrome, mostrando muchas funciones disponibles.", width="500", height="243" %}
  <figcaption>
   <a href="https://github.com/tomayac/fugu-greetings">Fugu Greetings</a> en ejecuci√≥n en Android Chrome.
  </figcaption>
</figure>

<figure>
 {% Img src ="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/BOcbAW4FCi10d9cGdeNW.png", alt="Fugu Greetings ejecut√°ndose en Safari de escritorio, mostrando menos funciones disponibles.", width="500", height="403" %}
 <figcaption> <a href="https://github.com/tomayac/fugu-greetings">Fugu Greetings</a> en ejecuci√≥n en Safari de escritorio.
 </figcaption>
</figure>

<figure>
 {% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/7zT4BEUzxTkjg8e08OJU.png", alt="Fugu Greetings en ejecuci√≥n en Chrome para escritorio, mostrando varias funciones disponibles.", width="500", height="348" %}
  <figcaption> <a href="https://github.com/tomayac/fugu-greetings">Fugu Greetings</a> en ejecuci√≥n en Chrome para escritorios.
  </figcaption>
</figure>

Si est√° interesado en la [aplicaci√≥n Fugu Greetings](https://tomayac.github.io/fugu-greetings/public/) b√∫squelo y [bif√∫rquelo en GitHub](https://github.com/tomayac/fugu-greetings).

<figure>
 {% Img src="image/tcFciHGuF3MxnTr1y5ue01OGLBn2/l260mtBzRi8OxdV8gXSg.png", alt="Repo de Fugu Greetings en GitHub.", width="800", height="490" %}
  <figcaption>
   <a href="https://github.com/tomayac/fugu-greetings">Aplicaci√≥n Fugu Greetings</a> en GitHub.
  </figcaption>
</figure>

El equipo de Chromium est√° trabajando duro para hacer que mejorar las API avanzadas de Fugu. Al aplicar mejoras progresivas en el desarrollo de mi aplicaci√≥n, me aseguro de que todos obtengan una experiencia de referencia s√≥lida e inclusiva, y que las personas que utilizan navegadores que admiten a√∫n m√°s API de plataformas web obtengan una experiencia a√∫n mejor. Espero ver lo que hace con la mejora progresiva en sus aplicaciones.

## Agradecimientos

Mil gracias a [Christian Liebel](https://christianliebel.com/) y [Hemanth HM](https://h3manth.com/) quienes han contribuido a Fugu Greetings. Este art√≠culo fue revisado por [Joe Medley](https://github.com/jpmedley) y [Kayce Basques](https://github.com/kaycebasques). [Jake Archibald](https://github.com/jakearchibald/) me ayud√≥ a descubrir la situaci√≥n con el `import()` din√°mico en el contexto de los service workers.
